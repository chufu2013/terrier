#pragma once

#include <memory>
#include <string>
#include <utility>
#include <vector>
#include "common/strong_typedef.h"
#include "execution/compiler/codegen.h"
#include "execution/compiler/function_builder.h"
#include "execution/compiler/operator/operator_translator.h"
#include "execution/exec_defs.h"
#include "execution/util/region.h"

namespace terrier::execution::compiler {

/**
 * A single pipeline
 */
class Pipeline {
 public:
  /**
   * Constructor
   * @param codegen the code generator to use
   */
  explicit Pipeline(CodeGen *codegen) : codegen_(codegen) {}

  /**
   * Add an operator translator to the pipeline
   * @param translator translator to add
   */
  void Add(std::unique_ptr<OperatorTranslator> &&translator) {
    is_vectorizable_ = is_vectorizable_ && translator->IsVectorizable();
    is_parallelizable_ = is_parallelizable_ && translator->IsParallelizable();
    pipeline_.emplace_back(std::move(translator));
  }

  /**
   * @return the pipelines' function id
   */
  ast::Identifier GetPipelineName() {
    return codegen_->Context()->GetIdentifier("pipeline" + std::to_string(!pipeline_idx_));
  }

  /**
   * Create a unique name for a function local to this pipeline
   * @param func_name The function name
   * @return the constructed string
   */
  std::string ConstructPipelineFunctionName(const std::string &func_name) const {
    // The result will be in the format of PipelineX_funcname
    auto result = fmt::format("Pipeline{}", pipeline_idx_);
    if (!func_name.empty()) {
      result += "_" + func_name;
    }
    return result;
  }

  /**
   * Get the identifier of the pipeline function
   * @return the identifier made from the unique pipeline function name
   */
  ast::Identifier GetWorkFunctionName() const {
    // TODO(Yuhong): name the function according to whether the pipeline is parallel
    const auto &name = ConstructPipelineFunctionName("ParallelWork");
    return codegen_->MakeIdentifier(name);
  }

  /**
   * @return the root operator in the pipeline
   */
  OperatorTranslator *Root() const { return pipeline_[0].get(); }

  /**
   * Generate the top level declarations of this pipeline
   * @param decls list of functions and structs
   * @param state_fields list of state fields
   * @param setup_stmts list of stmts for the setup function
   * @param teardown_stmts list of stmts for the teardown functiono
   */
  void Initialize(util::RegionVector<ast::Decl *> *decls, util::RegionVector<ast::FieldDecl *> *state_fields,
                  util::RegionVector<ast::Stmt *> *setup_stmts, util::RegionVector<ast::Stmt *> *teardown_stmts);

  /**
   * Produce the code of this pipeline
   * @param query_id query identifier
   * @param pipeline_idx index of of this pipeline
   * @return the function generated by this pipeline
   */
  ast::Decl *Produce(query_id_t query_id, pipeline_id_t pipeline_idx);

  /**
   * Gets the vector of operators that make up the pipeline
   * @return vector of pipeline operators
   */
  const std::vector<std::unique_ptr<OperatorTranslator>> &GetTranslators() const { return pipeline_; }

  /**
   * @return True if the pipeline is parallel; false otherwise.
   */
  bool IsParallel() const { return is_parallelizable_; }

 private:
  CodeGen *codegen_;
  std::vector<std::unique_ptr<OperatorTranslator>> pipeline_{};
  pipeline_id_t pipeline_idx_{0};
  bool is_vectorizable_{true};
  bool is_parallelizable_{true};
};

}  // namespace terrier::execution::compiler
